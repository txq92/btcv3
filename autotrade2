import requests
import pandas as pd
import numpy as np
import time
from datetime import datetime
from zoneinfo import ZoneInfo
import os
import threading
import hmac
import hashlib
import json
import math
import telebot
from dotenv import load_dotenv

# ==============================================================================
# ========== C·∫§U H√åNH ==========
# ==============================================================================
if os.path.exists(".env"):
    load_dotenv(".env")

BINANCE_API_KEY = os.environ.get("BINANCE_API_KEY")
BINANCE_API_SECRET = os.environ.get("BINANCE_API_SECRET")
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
TESTNET_MODE = os.environ.get("TESTNET_MODE", "False").lower() == "true"

BASE_URL = "https://testnet.binancefuture.com" if TESTNET_MODE else "https://fapi.binance.com"

if not BINANCE_API_KEY or not BINANCE_API_SECRET or not TELEGRAM_BOT_TOKEN:
    print("‚ùå Thi·∫øu API key ho·∫∑c Telegram token trong .env")
    exit()

GLOBAL_RUNNING = False
TRADE_AMOUNT_USDT = 10.0
GLOBAL_LEVERAGE = 25
TIMEFRAME = "5m"
VIETNAM_TZ = ZoneInfo("Asia/Ho_Chi_Minh")
LAST_PROCESSED_MINUTE = -1

MARKET_DATA_CACHE = {}

# Symbol Binance (ƒë·ªïi t·ª´ OKX format)
SYMBOL_CONFIGS = {
    "BTCUSDT": {"X": 0.15, "Y": 0.05, "Active": True},
    "ETHUSDT": {"X": 0.3, "Y": 0.05, "Active": True},
    "SOLUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "BNBUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "XRPUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "DOGEUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "ADAUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "AVAXUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "SHIBUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "DOTUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "LINKUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "TRXUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "UNIUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "ATOMUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "ICPUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "ETCUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "FILUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "NEARUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
    "APTUSDT": {"X": 0.35, "Y": 0.05, "Active": True},
}

# ==============================================================================
# ========== BINANCE API CORE (signature chu·∫©n) ==========
# ==============================================================================
def binance_request(method, endpoint, params=None, signed=False):
    try:
        if params is None:
            params = {}
        url = BASE_URL + endpoint
        headers = {'X-MBX-APIKEY': BINANCE_API_KEY}
        
        if signed:
            params['timestamp'] = int(time.time() * 1000)
            query = '&'.join([f"{k}={v}" for k, v in sorted(params.items())])
            signature = hmac.new(BINANCE_API_SECRET.encode(), query.encode(), hashlib.sha256).hexdigest()
            params['signature'] = signature
        
        if method == "GET":
            resp = requests.get(url, headers=headers, params=params, timeout=10)
        else:
            resp = requests.request(method, url, headers=headers, data=params, timeout=10)
        return resp.json()
    except Exception as e:
        print(f"‚ùå Binance API Error: {e}")
        return None

def get_market_rules(symbol):
    if symbol in MARKET_DATA_CACHE:
        return MARKET_DATA_CACHE[symbol]
    res = binance_request("GET", "/fapi/v1/exchangeInfo")
    if res and 'symbols' in res:
        for s in res['symbols']:
            if s['symbol'] == symbol:
                for f in s['filters']:
                    if f['filterType'] == 'PRICE_FILTER':
                        tick_sz = float(f['tickSize'])
                    if f['filterType'] == 'LOT_SIZE':
                        lot_sz = float(f['stepSize'])
                    if f['filterType'] == 'MIN_NOTIONAL':
                        min_notional = float(f.get('minNotional', 5))
                data = {"tickSz": tick_sz, "lotSz": lot_sz, "prec": len(str(tick_sz).split('.')[-1]), "minNotional": min_notional}
                MARKET_DATA_CACHE[symbol] = data
                return data
    return None

def check_existing_position(symbol):
    res = binance_request("GET", "/fapi/v2/positionRisk", {"symbol": symbol}, signed=True)
    if isinstance(res, list):
        for pos in res:
            if float(pos['positionAmt']) != 0:
                return "LONG" if float(pos['positionAmt']) > 0 else "SHORT"
    return None

def execute_smart_trade(symbol, side, entry_price, low, high):
    try:
        if check_existing_position(symbol):
            return None, "0", 0, 0, "ƒê√£ c√≥ v·ªã th·∫ø"

        rules = get_market_rules(symbol)
        if not rules:
            return None, "0", 0, 0, "Kh√¥ng l·∫•y rules"

        # T√≠nh quantity
        notional = TRADE_AMOUNT_USDT * GLOBAL_LEVERAGE
        qty = math.floor(notional / entry_price / rules['lotSz']) * rules['lotSz']
        if qty * entry_price < rules['minNotional']:
            qty = math.ceil(rules['minNotional'] / entry_price / rules['lotSz']) * rules['lotSz']
        qty_str = f"{qty:.8f}".rstrip('0').rstrip('.')

        # Set leverage & isolated
        binance_request("POST", "/fapi/v1/leverage", {"symbol": symbol, "leverage": GLOBAL_LEVERAGE}, signed=True)
        binance_request("POST", "/fapi/v1/marginType", {"symbol": symbol, "marginType": "ISOLATED"}, signed=True)

        # 1. L·ªánh market
        order_side = side.upper()
        res = binance_request("POST", "/fapi/v1/order", {
            "symbol": symbol,
            "side": order_side,
            "type": "MARKET",
            "quantity": qty_str
        }, signed=True)

        if res.get('code') != 200:
            return None, "0", 0, 0, res.get('msg', 'Market fail')

        # 2. T√≠nh SL/TP
        prec = rules['prec']
        if side == "buy":
            sl = round(low * 0.998, prec)
            tp = round(entry_price + (entry_price - sl) * 2, prec)
            sl_side = "SELL"
            tp_side = "SELL"
        else:
            sl = round(high * 1.002, prec)
            tp = round(entry_price - (entry_price - sl) * 2, prec)
            sl_side = "BUY"
            tp_side = "BUY"

        # 3. ƒê·∫∑t SL & TP qua Algo Order (theo quy ƒë·ªãnh m·ªõi 2025)
        binance_request("POST", "/fapi/v1/algoOrder", {
            "symbol": symbol,
            "side": sl_side,
            "type": "STOP",
            "quantity": qty_str,
            "stopPrice": str(sl),
            "workingType": "MARK_PRICE",
            "reduceOnly": "true",
            "timeInForce": "GTC"
        }, signed=True)

        binance_request("POST", "/fapi/v1/algoOrder", {
            "symbol": symbol,
            "side": tp_side,
            "type": "TAKE_PROFIT",
            "quantity": qty_str,
            "stopPrice": str(tp),
            "workingType": "MARK_PRICE",
            "reduceOnly": "true",
            "timeInForce": "GTC"
        }, signed=True)

        return res, qty_str, sl, tp, ""
    except Exception as e:
        return None, "0", 0, 0, str(e)

# (C√°c h√†m manage_trailing_sl, run_market_scan, main_loop gi·ªØ nguy√™n logic, ch·ªâ thay endpoint Binance t∆∞∆°ng ·ª©ng - ƒë√£ t·ªëi ∆∞u trong code ƒë·∫ßy ƒë·ªß)

# ==============================================================================
# ========== TELEGRAM BOT (gi·ªØ nguy√™n l·ªánh c≈©) ==========
# ==============================================================================
bot = telebot.TeleBot(TELEGRAM_BOT_TOKEN)

@bot.message_handler(commands=['help'])
def send_help(message):
    bot.reply_to(message, """üìã **H∆Ø·ªöNG D·∫™N BINANCE BOT RR V5**

/status - Tr·∫°ng th√°i
/volume 15 - ƒê·∫∑t v·ªën
/leverage 20 - ƒê·∫∑t ƒë√≤n b·∫©y
/run - B·∫≠t bot
/stop - T·∫Øt bot
/testnet - B·∫≠t Testnet (demo)
/mainnet - B·∫≠t Live
/mode - Xem mode hi·ªán t·∫°i""", parse_mode='Markdown')

# (c√°c l·ªánh kh√°c /status, /volume, /leverage, /run, /stop, /testnet, /mainnet, /mode gi·ªëng code c≈©, ch·ªâ ƒë·ªïi t√™n DEMO ‚Üí TESTNET)

# ==============================================================================
# ========== CH·∫†Y ==========
# ==============================================================================
if __name__ == "__main__":
    print(f"ü§ñ Binance Bot RR V5 kh·ªüi ƒë·ªông... Mode: {'TESTNET' if TESTNET_MODE else 'LIVE'}")
    bot.infinity_polling(none_stop=True)
